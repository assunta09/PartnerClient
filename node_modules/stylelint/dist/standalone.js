"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var files = _ref.files;
  var code = _ref.code;
  var codeFilename = _ref.codeFilename;
  var config = _ref.config;
  var configFile = _ref.configFile;
  var configBasedir = _ref.configBasedir;
  var configOverrides = _ref.configOverrides;
  var ignoreDisables = _ref.ignoreDisables;
  var ignorePath = _ref.ignorePath;
  var reportNeedlessDisables = _ref.reportNeedlessDisables;
  var syntax = _ref.syntax;
  var _ref$formatter = _ref.formatter;
  var formatter = _ref$formatter === undefined ? "json" : _ref$formatter;

  var isValidCode = typeof code === "string";
  if (!files && !isValidCode || files && (code || isValidCode)) {
    throw new Error("You must pass stylelint a `files` glob or a `code` string, though not both");
  }

  return (0, _buildConfig2.default)({
    config: config,
    configFile: configFile,
    configBasedir: configBasedir,
    configOverrides: configOverrides,
    ignorePath: ignorePath
  }).then(function (_ref2) {
    var config = _ref2.config;
    var configDir = _ref2.configDir;


    // Prepare processors
    var codeProcessors = [];
    var resultProcessors = [];
    if (config.processors) {
      [].concat(config.processors).forEach(function (processorConfig) {
        processorConfig = [].concat(processorConfig);
        var processorLookup = processorConfig[0];
        var processorOptions = processorConfig[1];
        var processor = require(processorLookup);
        processor = processor.default || processor;
        var initializedProcessor = processor(processorOptions);
        if (initializedProcessor.code) {
          codeProcessors.push(initializedProcessor.code);
        }
        if (initializedProcessor.result) {
          resultProcessors.push(initializedProcessor.result);
        }
      });
    }

    var chosenFormatter = formatter;

    if (typeof chosenFormatter === "string") {
      if (_lodash2.default.includes(Object.keys(formatters), chosenFormatter)) {
        chosenFormatter = formatters[chosenFormatter];
      } else {
        throw new Error("You must use a valid formatter option, either: json, string or verbose");
      }
    }

    var errored = false;

    var initialisedPostcss = void 0;

    var isFileIgnored = (0, _getIsFileIgnored2.default)(config.ignorePatterns, config.ignoreFiles);

    function prepareReturnValue(results) {
      var returnValue = {
        results: results,
        errored: errored,
        output: chosenFormatter(results)
      };
      if (reportNeedlessDisables) {
        returnValue.needlessDisables = (0, _needlessDisables2.default)(results);
      }
      return returnValue;
    }

    if (!files) {
      return lintString(code, codeFilename).then(function (result) {
        var results = [result];
        return prepareReturnValue(results);
      });
    }

    return (0, _globby2.default)([].concat(files, ignoredGlobs)).then(function (input) {
      if (!input.length) {
        var err = new Error("Files glob patterns specified did not match any files");
        err.code = 80;
        throw err;
      }
      var promises = input.map(function (filepath) {
        return lintFile(filepath);
      });
      return Promise.all(promises).then(function (results) {
        return prepareReturnValue(results);
      });
    });

    function lintFile(filepath) {
      return new Promise(function (resolve, reject) {
        (0, _fs.readFile)(filepath, "utf8", function (err, code) {
          if (err) {
            return reject(err);
          }
          resolve(code);
        });
      }).then(function (code) {
        return lintString(code, filepath);
      });
    }

    function getPostcss() {
      if (!initialisedPostcss) {
        initialisedPostcss = (0, _postcss2.default)().use((0, _postcssPlugin2.default)({
          config: config,
          configFile: configFile,
          configBasedir: configBasedir,
          configOverrides: configOverrides,
          // If we are reporting needless disables, we have to ignore them
          ignoreDisables: reportNeedlessDisables ? true : ignoreDisables,
          ignorePath: ignorePath,
          _configPromise: Promise.resolve({ config: config, configDir: configDir })
        }));
      }

      return initialisedPostcss;
    }

    function lintString(code, filepath) {
      var postcssProcessOptions = {};
      if (filepath) {
        if (isFileIgnored(_path2.default.resolve(filepath))) {
          return new Promise(function (resolve) {
            resolve({
              root: { source: { input: { file: filepath } } },
              messages: [],
              stylelint: {
                stylelintError: null,
                ignored: true
              },
              standaloneIgnored: true
            });
          }).then(handleResult);
        }

        postcssProcessOptions.from = filepath;
      }

      var fileExtension = _path2.default.extname(filepath || "");
      if (syntax === "scss" || !syntax && fileExtension === ".scss") {
        postcssProcessOptions.syntax = _postcssScss2.default;
      } else if (syntax === "less" || !syntax && fileExtension === ".less") {
        postcssProcessOptions.syntax = _postcssLess2.default;
      } else if (syntax === "sugarss" || !syntax && fileExtension === ".sss") {
        postcssProcessOptions.syntax = _sugarss2.default;
      } else if (syntax) {
        throw new Error("You must use a valid syntax option, either: scss, less or sugarss");
      }

      codeProcessors.forEach(function (codeProcessor) {
        code = codeProcessor(code, filepath);
      });

      return getPostcss().process(code, postcssProcessOptions).then(handleResult).catch(cssSyntaxError);

      function handleResult(postcssResult) {
        var source = !postcssResult.root.source ? undefined : postcssResult.root.source.input.file || postcssResult.root.source.input.id;

        if (postcssResult.stylelint.stylelintError) {
          errored = true;
        }

        // Strip out deprecation warnings from the messages
        var deprecations = _lodash2.default.remove(postcssResult.messages, { stylelintType: "deprecation" }).map(function (d) {
          return {
            text: d.text,
            reference: d.stylelintReference
          };
        });

        // Also strip out invalid options
        var invalidOptionWarnings = _lodash2.default.remove(postcssResult.messages, { stylelintType: "invalidOption" }).map(function (w) {
          return { text: w.text };
        });

        // This defines the stylelint result object that formatters receive
        var stylelintResult = {
          source: source,
          deprecations: deprecations,
          invalidOptionWarnings: invalidOptionWarnings,
          errored: postcssResult.stylelint.stylelintError,
          warnings: postcssResult.messages.map(function (message) {
            return {
              line: message.line,
              column: message.column,
              rule: message.rule,
              severity: message.severity,
              text: message.text
            };
          }),
          ignored: postcssResult.stylelint.ignored,
          _postcssResult: postcssResult
        };

        resultProcessors.forEach(function (resultProcessor) {
          // Result processors might just mutate the result object,
          // or might return a new one
          var returned = resultProcessor(stylelintResult, filepath);
          if (returned) {
            stylelintResult = returned;
          }
        });

        return stylelintResult;
      }

      function cssSyntaxError(error) {
        if (error.name !== "CssSyntaxError") {
          throw error;
        }

        errored = true;
        return {
          source: error.file || "<input css 1>",
          deprecations: [],
          invalidOptionWarnings: [],
          errored: true,
          warnings: [{
            line: error.line,
            column: error.column,
            rule: error.name,
            severity: "error",
            text: error.reason + " (" + error.name + ")"
          }]
        };
      }
    }
  });
};

var _formatters = require("./formatters");

var formatters = _interopRequireWildcard(_formatters);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _buildConfig = require("./buildConfig");

var _buildConfig2 = _interopRequireDefault(_buildConfig);

var _getIsFileIgnored = require("./utils/getIsFileIgnored.js");

var _getIsFileIgnored2 = _interopRequireDefault(_getIsFileIgnored);

var _globby = require("globby");

var _globby2 = _interopRequireDefault(_globby);

var _postcssLess = require("postcss-less");

var _postcssLess2 = _interopRequireDefault(_postcssLess);

var _needlessDisables = require("./needlessDisables");

var _needlessDisables2 = _interopRequireDefault(_needlessDisables);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _fs = require("fs");

var _postcssScss = require("postcss-scss");

var _postcssScss2 = _interopRequireDefault(_postcssScss);

var _postcssPlugin = require("./postcssPlugin");

var _postcssPlugin2 = _interopRequireDefault(_postcssPlugin);

var _sugarss = require("sugarss");

var _sugarss2 = _interopRequireDefault(_sugarss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ignoredGlobs = ["!**/node_modules/**", "!**/bower_components/**"];